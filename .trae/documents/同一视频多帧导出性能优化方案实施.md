## 性能瓶颈分析
- 初始化/释放成本：每次创建/释放 `MediaMetadataRetriever`（Android）或 `AVAssetImageGenerator`（iOS）较重。
- 随机寻址开销：按任意时间点读取会频繁跨关键帧跳转，I/O 与解码器状态切换成本高。
- 解码与像素处理：全分辨率解码、旋转、缩放、编码（PNG/JPEG）都是 CPU 密集型。
- 编码选择：PNG 无损但耗时，JPEG 有损且更快；质量越高耗时越久。
- 线程与并发：同一视频多线程解码导致硬件/软件解码器竞争，线程切换与内存压力增大。
- 通道传输：大量二进制数据通过平台通道频繁往返，序列化与拷贝会放大延迟。

## 总体优化策略
1. 资源复用与批量接口
- 复用同一视频的解码器：一次 `setDataSource` 后复用对象，避免反复初始化释放。
- 新增批量 API：`getFrames(filePath, seconds[], options)`，同一视频一次性请求多帧，以降低通道与初始化的总成本。

2. 解码与寻址策略
- 有序请求：将 `seconds[]` 升序处理，减少跨远距离跳转。
- 容忍度/关键帧策略：
  - Android：同视频使用 `OPTION_CLOSEST`（更快更准），必要时才用 `OPTION_CLOSEST_SYNC`。
  - iOS：`requestedTimeToleranceBefore/After` 非零时显著提速；只有确需精准时设为 `.zero`。
- 预取邻近：对相近时间点集中处理，利用解码器的缓存与状态（尤其 iOS 的异步生成）。

3. 像素与编码优化
- 尺寸控制：尽量在生成阶段就限制尺寸（iOS 用 `maximumSize`；Android 控制目标尺寸并仅一次旋转/缩放）。
- 编码选择：默认 `jpeg(quality≈80-90)`；仅在强需求时使用 `png`。
- 旋转策略：可选 `applyRotation` 开关，默认应用；性能敏感场景关闭以减少计算。
- 内存复用：重用 `ByteArrayOutputStream`（设置初始容量），及时 `recycle` 位图，避免峰值内存。

4. 并发与队列
- 同一视频采用“单视频单队列”串行处理，避免解码器资源竞争；多个视频可并行（根据设备能力设置上限）。
- 后台执行，主线程仅回调结果；避免主线程阻塞。

5. 通道与返回形式
- 批量返回：一次性把多帧作为 `List<Uint8List>` 返回，降低往返次数。
- 可选持久化：允许选项 `returnPath=true` 保存到缓存目录并返回路径，减少通道拷贝（如需极致性能）。

## 具体改动计划（代码级）
- Dart 公共 API（lib/video_frame_extractor.dart:4）
  - 新增：`static Future<List<Uint8List?>> getFrames(String filePath, {required List<double> seconds, int? width, int? height, String format = 'jpeg', int quality = 85, bool exactTime = false, bool applyRotation = true})`
  - 保持现有 `getFrame`，内部转发到 `getFrames`。
- 平台接口（lib/video_frame_extractor_platform_interface.dart:30）
  - 新增 `getFrames(...)` 抽象方法，对应参数一致。
- MethodChannel（lib/video_frame_extractor_method_channel.dart:10）
  - 新增 `invokeMethod<List<dynamic>>('getFrames', args)`，把返回 `List<Uint8List>`。
- Android（android/src/main/kotlin/com/chanwind/video_frame_extractor/VideoFrameExtractorPlugin.kt:22）
  - 增加 `getFrames` 分支：
    - 建立并复用单个 `MediaMetadataRetriever`（一次 `setDataSource`）。
    - 对 `seconds` 升序遍历：计算 `timeUs`，`OPTION_CLOSEST`/`OPTION_CLOSEST_SYNC` 按需选择。
    - 仅一次读取旋转角度；按选项决定是否应用旋转。
    - 按目标尺寸缩放（等比），编码为 JPEG（默认），收集到 `List<byte[]>`。
    - 后台线程执行，主线程返回结果。
  - 可选：维护简单 LRU（按 `filePath`）缓存 retriever，暴露 `release(filePath)` 清理接口（后续迭代）。
- iOS（ios/Classes/VideoFrameExtractorPlugin.swift:11）
  - 增加 `getFrames` 分支：
    - 创建单个 `AVAssetImageGenerator`，设置 `appliesPreferredTrackTransform` 与 `maximumSize`。
    - 使用 `generateCGImagesAsynchronously(forTimes:)` 一次性异步生成多帧；容忍度按 `exactTime` 决定。
    - 将每帧按选择格式编码为 `Data`，组装为 `Array<FlutterStandardTypedData>` 返回。

## 选项与默认值
- `format='jpeg'`，`quality=85`，`exactTime=false`，`applyRotation=true`。
- 如需更快：`format='jpeg'`, `quality=75`，`applyRotation=false`，尽量提供较小的 `width/height`。

## 验证与度量
- 在 example 添加基准用例：同一 30s 视频上按 100 个时间点批量导出，统计总耗时与每帧平均耗时。
- 对比：
  - 逐帧单次 API vs 批量 API
  - `png` vs `jpeg(85)` vs `jpeg(75)`
  - `exactTime=true` vs `false`
- 设备覆盖：中低端 Android 与 iOS 模拟器/真机。

## 交付与迭代
- 首次交付：批量 API、资源复用与异步生成（iOS），串行处理（Android）。
- 后续增强：
  - Android 可选切换到 `MediaCodec`/`MediaExtractor` 管线以进一步提升性能（复杂度更高）。
  - 通道返回路径模式，降低大规模数据传输压力。

若确认上述方案，我将按计划在两端与 Dart 层实现批量导出与资源复用，并补充示例与基准测试。